# Search problem

<br>

对于搜索算法, 最基础的算法就是 Linear Search.
对于线性搜索算法来说, 它的时间复杂度为 `O(n)`,
就像算法的名字一样, 搜索一个元素是否存在于一个序列中, 需要依次遍历序列中的所有元素.

## Binary Search (or Bisection Search)

同样是根据 Divide and Conquer 的思想, 二分查找是最常用的搜索算法之一.
比如设 `L=[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]`, 查找 `integer x ∈ L: True/False`.

```
if x = 19

[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
               ↓
[1, 3, 5, 7, 9], [11, 13, 15, 17, 19]
                         ↓
                 [11, 13], [15, 17, 19]
                                ↓
                            [15, 17], [19]
                                        ↓
                                      True
```

对于二分查找, 如果我们采用递归的方式实现, 则有:
`T(n) = 1 * T(n/2) + O(1); T(1) = O(1)`.
根据在归并排序中介绍的 Master Theorem, 解得 `T(n) = O(logn)`.

## Linear Search vs. Binary Search

通过对二者复杂度的分析, 是否我们就可以得出结论二分查找比线性查找快?

答案是__否定__的. 因为二分查找的一个重要的前提条件是, 搜索的序列是__经过排序的__.

- Linear Search: `O(n)`
- Sort + Binary Search: `O(nlogn) + O(logn)`

对比一下我们就可以知道,
对于未经过排序的序列, 二分查找只有在序列长度非常大的时候才会比线性查找快.
